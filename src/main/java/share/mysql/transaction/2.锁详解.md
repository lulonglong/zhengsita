```
		本次深入讲解锁相关知识，在事务的讲解中已经对锁各种维度的分类做了描述，此处不再重复。另外提一句，MyISAM、MEMORY、MERGE存储引擎只支持表级锁。以下讲解的都是InnoDB的锁内容。
```

## 不常见的锁
#### InnoDB表锁
```
		什么，表锁竟然不常见？是的，InnoDB在实现过程中几乎没用表锁，只在系统恢复时用到了表锁。那update没命中索引的时候需要全表扫描，是加的什么锁？答案是加的行锁，大面积的行锁，后面讲。

//TODO 这里涉及到锁的结构，同一个事务同一个页内的相同类型的锁，是可以放在一个锁结构中的，就相当于是针对页面加了锁。
```
#### MDL(元数据锁)
```
		当有DDL操作时，会先等待当前执行的事务提交。并且会阻塞后来的其他读写操作。这是Server层用元数据锁实现的，并非在InnoDB层。
		元数据锁是server层的锁，表级锁（区别于InnoDB层的表锁，不是同一层的东西），每执行一条DML、DDL语句时都会申请metadata锁，DML操作需要metadata读锁，DDL操作需要metadata写锁，metadata加锁过程是系统自动控制，无法直接干预，读锁和写锁的阻塞关系如下：
读锁和写锁之间相互阻塞，即同一个表上的DML和DDL之间互相阻塞。
写锁和写锁之间互相阻塞，即两个session不能对表同时做表定义变更，需要串行操作。
```
#### 表级别的AUTO-INC锁
```
		如果表的某列指定是自增的（每个表最多支持一个自增列），在执行插入语句时会有两种方式。
1.AUTO-INC锁，插入时获取锁，插入语句结束就释放，不等事务结束就释放了，这一点跟其他锁不一样。
2.轻量级锁，在获取自增值的时候加锁，获取到值就释放锁，不需要等待插入语句的执行。
innodb_autoinc_lock_mode可以配置采用的模式
>0：代表AUTO-INC表锁（传统模式）
>1：代表轻量级锁（连续模式）
>2：两者混着来（交叉模式），当能确定一个insert插入的数据数量时，直接用轻量级锁获取一个固定数量，否则加AUTO-INC表锁
		在 MySQL 8.0 之前，InnoDB 锁模式默认为连续模式，值为1，而在 MySQL 8.0 之后，默认模式变成了交叉模式。因为Mysql8.0之前，备份（binlog）默认是基于语句（statement模式）的复制。而Mysql8.0开始，binlog默认是基于行（row模式）的复制。AUTO-INC连续模式配合binlog的statement模式会导致主从数据不一致。
		//TODO先看下insert的加锁过程，连续的insert是否会阻塞？ 这里之前有个疑问，在binlog是statement模式下使用AUTO-INC表锁好像也保证不了主从库自增列的值是一致的。例如事务T1在时间点①insert语句。事务T2在时间点②insert语句，随后T2先提交，T1后提交
```
#### 插入意向锁
```
		当insert一条数据时，会找到插入的位置，看后边一条数据AA是否持有gap锁，如果有gap锁那么需要等待，这时会生成一个插入意向锁加在AA上。如果其他事务也有同样的insert，并且后一条数据也是AA，那也生成一个插入意向锁加在AA上。插入意向锁仅仅代表要在AA数据之前的gap有插入数据的需求，彼此之间不互斥。基本没啥用
```
#### 隐式锁
```
		当insert一条数据BB时，会找到插入的位置，看后边一条数据AA是否持有gap锁，如果没有则可以插入数据。这时如果有事务想对这条数据修改，则会出现问题。除非插入BB后在BB上加一把锁，但其实并没这么做，在聚簇索引中每行记录都有一个trx_id，其他事务在更新时可以查看这条记录的trx_id是否在活跃事务列表中，如果活跃则替BB加上X锁。就是说，隐式锁就是不加锁，通过trx_id来传达信息。让修改它的的事务延迟帮它加锁。
```



## 锁结构

![](https://img-blog.csdnimg.cn/ecefe3315398479f95d9b7d043162a65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5b-X55qE5Y2a5a6i,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
![](https://mmbiz.qpic.cn/mmbiz_png/ZB8eCu1DibibIzXj3U4NHxicPYEczjzTUPtJCgxibVPzB7mXC3fPXeVeZJaFT4gaSsxQvcz8fU1BYxPx76F0SbWQQg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
锁结构，trx事务信息，is_waiting是否等待获取锁
隐式锁
一致性读和快照读是一个概念，区别于锁定读
锁定读 select lock in share mode。select for update
insert对应的是隐式锁

myisam，读加表读锁，写加表写锁
在ddl时会产生元数据锁mdl

自增列使用表级的AUTO_INCREMENT锁，只在插入语句执行的时候加锁，插完就释放，哪怕事务还没提交也释放。还有一种是轻量级锁，只在获取自增编号的时候加锁，获取到自增编号就释放锁，不等语句插入执行完毕。默认是插入语句行数不确定的情况下用前者，数量确定的情况下用后者。innodb_autoinc_lock_mode参数可调节0代表采用AUTO-INC锁，2代表轻量级锁，1代表混着用。MySQL 8.0之前默认设置是1，之后默认设置是2。当主从复制时如果设置的是语句复制，采用2会出现主从自增id不连续不一致的情况。如果使用0是不是也会出现数据主键不一致，这个得查下，确认下？

gap锁，如果记录是1、5、10，那么在10上加gap锁影响的是（5，10）的区间，如果一条记录插入时，如果插入6，会找到10查看10上是否有gap锁。gap锁不区分读写，可以多个事务重复加，只是为了防止幻读设计的。10以后的gap锁怎么加，加到所在页的supremum记录上，默认存在的最大记录行
next-key只是record和gap锁的合体

插入意向锁，当插入数据时，查看后一条记录是否有gap锁，如果有就生成一个插入意向锁。实际上并没有这么干。而是采用的隐式锁方案，插入的时候并不生成锁结构，只是单纯的阻塞，等数据成功插入后。如果有一个事务要修改这条数据，那么这个事务将会为插入的记录生成锁结构，相当于延时生成锁结构。大部分的插入不会出现并发改的情况，所以就省去了生成锁结构的操作。

锁的详细结构

串行隔离级别下，如果是自动提交则读不加锁。如果是非自动提交，则读加读锁所类型与可重复读一样。这种隔离级别下也会用到mvcc，并不是说mvcc只用在读已提交和可重复读上。

不同隔离级别加锁的类型、过程、以及提前释放锁的相关东西

对每行加锁的过程是先对记录加锁再判断是否符合条件，这点很重要，这就是为什么会多锁下一个区间

只有server层有释放锁的权限，引擎层不配释放锁。所以会出现二级索引的锁数量大于一级索引上的锁数量的情况，因为某些情况通过索引下推就能在引擎层判断记录是否符合条件，如果不符合就出现了二级索引上有锁，一级索引上没锁的情况



对于update更新，如果通过id筛选，但是更新到了二级索引，那对应的二级索引记录要加锁（隐式锁）



| 隔离级别   | 读锁定匹配模式（select\update） | 下一个区间加锁类型 |
| ---------- | ------------------------------- | ------------------ |
| <=读已提交 | 区间匹配                        | record             |
|            | 精确匹配                        | 不加锁             |
|            | 唯一匹配                        | record             |
| >=可重复读 | 区间匹配                        | next-key           |
|            | 精确匹配                        | gap                |
|            | 唯一匹配                        | record             |



半一致性读：在<=读已提交级别时，锁没用的话就会被释放。那么当update一条记录时，如果这条记录被其他事务锁住了，那么理论上应该阻塞等待锁定，但是这条记录其实不一定符合server的筛选条件，所以可以直接找到可读版本记录，返回给server，server判定符合条件再来等待加锁，如果server判断不符合条件则直接跳过本条记录。如果用等待锁的方式，那就是等到锁之后返回给server，server判断不符合条件，再释放锁，结果是一样的，但白白等了半天



insert遇到唯一索引，主键

| 隔离级别   | 主键     | 唯一二级索引                                                 |
| ---------- | -------- | ------------------------------------------------------------ |
| <=读已提交 | record   | next-key（事务A插入p1,u1，事务B插入p2,u1。如果加record锁在AB都还没提交的情况下，读未提交的级别事务C来查询数据即可查到两个u1，违反了唯一约束。只有加next-key才能解决问题） |
| >=可重复读 | next-key | next-key                                                     |

上述锁是加到了唯一索引记录上，实际上后一条记录也会加





QA
innodb中的表锁几乎没啥用。那为什么说不命中索引的时候会加表锁，表锁跟意向锁的判断中的表锁从哪里来？

## 参考文档
[MySQL是怎样运行的](https://item.jd.com/10023638908471.html)
[MySQL 元数据锁(MDL)](https://blog.csdn.net/Leon_Jinhai_Sun/article/details/125831693)
[75-MySQL-锁的内存结构](https://www.jianshu.com/p/10774b36247b)
[MySQL——锁](https://blog.csdn.net/li1325169021/article/details/121984573)
[InnoDB事务锁系统及其实现](https://mp.weixin.qq.com/s/W07ZIW0GRtsrS5nuiy2z_A)