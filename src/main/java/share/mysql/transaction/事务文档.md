# Mysql事务  

## 事务特性  

	注意:事务是脱离mysql的概念  

- 原子性(Atomicity)  
	- 指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。mysql通过undo log实现
- 隔离性(Isolation)  
	- 多个事务并发执行的时候，事务内部的操作与其他事务是隔离的。隔离性有不同的隔离等级要求，mysql通过锁和MVCC机制实现
- 持久性(Durability)  
	- 事务一旦提交，它对数据的改变就应该是永久性的。mysql通过redo log实现  
- 一致性(Consistency)  
	- 指事务执行前后，数据处于一种符合逻辑的状态。这里的逻辑根据业务场景来定义，是指业务上的正常逻辑
	- 一致性是事务的终极目标，mysql通过原子性、隔离性、持久性来保证数据一致性，AID是达成一致性的手段

	举例：A账户有200元，转账300元出去，此时A账户余额为-100元。此时数据是不合逻辑的，这就是不一致性，为什么呢？因为你定义了一个状态，余额不能小于0。不但需要数据库层面做到一致性，逻辑层面也要一致，才能最终保证事务的一致性。 数据库保证一致性，不代表整个业务也会一致性，数据库没有一致性，上层业务就没有一致性可言。 

***

## 隔离性的实现  

- 无隔离带来的几种问题  
	- 脏读：读到了其他事务未提交的数据   
	- 不可重复读：在同一事务内，不同的时刻读到的同一批数据可能是不一样的
	- 幻读：进行中的A事务读到了后开始的B事务刚刚提交的插入数据，针对insert的

- 隔离级别(SQL标准定义的)  
	- 读未提交（READ UNCOMMITTED）  
	- 读提交 （READ COMMITTED）（我们生产环境的级别）  
	- 可重复读 （REPEATABLE READ）（mysql默认级别）  
	- 串行化 （SERIALIZABLE）

>SQL标准中不同隔离级别的问题(Innodb里的可重复读解决了幻读问题)  
![alt 不同隔离级别的问题](https://pic4.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_1440w.jpg)  

***

## Mysql锁  

	基于锁的属性分类：共享锁、排他锁  
	基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁（后三者也属于行锁的范畴）  
	基于锁的状态分类：意向共享锁、意向排它锁

### 按属性分  

- 共享锁  
> 共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加写锁。  
![alt 共享锁](https://pic1.zhimg.com/80/v2-a251449b6e3181eb7e722946787ec298_1440w.png)  

- 排它锁  
> 排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。  
![alt 排他锁](https://pic3.zhimg.com/80/v2-9a6d8e8fe84799b2288cbb4fa2f27f6e_1440w.png)   

### 按粒度分  

- 表锁  
> 上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问（前提是两个锁是冲突的，后续描述也一样）  
特点： 粒度大，加锁简单，容易冲突  

- 行锁
> 锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问  
特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高  

- 记录锁(Record Lock)  
> 记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，事务在加锁后仅锁住表的一条记录（注意：只锁一条）  
查询条件必须命中唯一索引

- 间隙锁(Gap Lock)  
> 间隙锁属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间  
查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中，防止幻读问题

- 临键锁(Next-Key Lock)  
> 临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。  
select * from user_info where id>1 and id<=9 for update ;  
会锁住ID为 1,5,9的记录；同时会锁住，1至5,5至9,9至11的区间  
![alt 各种行锁](https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aupQuiaGicPz8qWdq0ddjUZTWe5MmjqKL5CL9R5mLNe8X5mLhcibibqRGpKQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 按状态分  
	状态锁包括意向共享锁和意向排它锁，把他们区分为状态锁的一个核心逻辑，是因为这两个锁都是描述是否可以对某一个表进行加表锁的状态，状态锁要锁的对象是表（很重要）
	为了提高对表加锁时的性能，避免一行一行地去遍历这张表的数据有没有被锁住

![alt 锁冲突表](https://pic4.zhimg.com/80/v2-37761612ead11ddc3762a4c20ddab3f3_1440w.jpg)

***

## 不同隔离级别的实现  
	读未提交：加写锁不加读锁
	读已提交和可重复读都是基于MVCC，读已提交写的时候加行锁，可重复读写的时候加临键锁
	串行化：加表锁，读的时候加共享锁，可以并发读。写的时候加排它锁，写的时候不允许读写  

### 读已提交&可重复读  	
	并发控制：LBCC和MVCC
	LBCC是Lock-Based Concurrent Control的简称，意思是基于锁的并发控制  
	MVCC是Multi-Version Concurremt Control的简称，意思是基于多版本的并发控制协议，通过版本号，避免同一数据在不同事务间的竞争  

#### ReadView结构  
	ReadView是事务开启时，当前所有活跃事务（还未提交的事务）的一个集合，ReadView数据结构决定了不同事务隔离级别下数据的可见性
![alt readview数据结构](https://pic1.zhimg.com/80/v2-ba01322104c8b77f2ccd56459f351054_720w.jpg)  

#### 有了readview，在访问某条记录时，按照以下步骤判断记录的某个版本是否可见(以可重复读举例，可重复读是开启事务时生成ReadView，读已提交是在每次执行sql的时候生成ReadView)
1. 如果被访问版本的trx_id，与readview中的row_trx_id值相同，表明当前事务在访问自己修改过的记录，该版本可以被当前事务访问；  
2. 如果被访问版本的trx_id，小于readview中的min_trx_id值，表明生成该版本的事务在当前事务生成readview前已经提交，该版本可以被当前事务访问；  
3. 如果被访问版本的trx_id，大于或等于readview中的max_trx_id值，表明生成该版本的事务在当前事务生成readview后才开启，该版本不可以被当前事务访问；  
4. 如果被访问版本的trx_id，值在readview的[min_trx_id和max_trx_id)之间，就需要判断trx_id属性值是不是在m_ids列表中？
	- 如果在：说明创建readview时生成该版本的事务还是活跃的，该版本不可以被访问  
	- 如果不在：说明创建readview时生成该版本的事务已经被提交，该版本可以被访问；生成readview时机RC隔离级别：每次读取数据前，都生成一个readview；RR隔离级别：在第一次读取数据前，生成一个readview；  

![alt mvcc readview](https://asset-i7.yit.com/URDM/09ce7f729f864af4b90edcdc54356e76_1424X808.jpeg)

### ※可重复读对幻读的解决  
![alt](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzkkRHibH0jLK3GSCicOrOdxB90AhKdDUn12K9SEajicD8H4DloDYjHesLdkyRoXDZHvg0UiaVe57gO3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  
![alt](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzkkRHibH0jLK3GSCicOrOdxB7yibXicxmPjLU7TjiaE59xT72iaxJvY15MNFuJNJV4gOIW5aB1jH5Cticng/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### ※为什么mysql的默认隔离级别是可重复读？  
	当年binlog只有statement一种模式，只同步sql语句，假设出现以下情况
	查询主库会有一行记录，查询从库没有记录
	原因是，在master上执行的是删后插，在从库上执行的是先插后删
	在可重复读的级别下，当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住
![alt](https://img-blog.csdnimg.cn/20190401164924919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3Nzc0Njk2,size_16,color_FFFFFF,t_70)


***

## 参考文档
[程序员，知道Mysql中ACID的原理吗](https://zhuanlan.zhihu.com/p/65281198)  
[MySQL事务隔离级别和实现原理](https://zhuanlan.zhihu.com/p/117476959)  
[Mysql里的锁](https://zhuanlan.zhihu.com/p/213814000)  
[MySQL 加锁处理分析](https://www.cnblogs.com/tutar/p/5878651.html)