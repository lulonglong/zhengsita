锁结构，trx事务信息，is_waiting是否等待获取锁
隐式锁
一致性读和快照读是一个概念，区别于锁定读
锁定读 select lock in share mode。select for update
insert对应的是隐式锁

myisam，读加表读锁，写加表写锁
在ddl时会产生元数据锁mdl

自增列使用表级的AUTO_INCREMENT锁，只在插入语句执行的时候加锁，插完就释放，哪怕事务还没提交也释放。还有一种是轻量级锁，只在获取自增编号的时候加锁，获取到自增编号就释放锁，不等语句插入执行完毕。默认是插入语句行数不确定的情况下用前者，数量确定的情况下用后者。innodb_autoinc_lock_mode参数可调节0代表采用AUTO-INC锁，2代表轻量级锁，1代表混着用。MySQL 8.0之前默认设置是1，之后默认设置是2。当主从复制时如果设置的是语句复制，采用2会出现主从自增id不连续不一致的情况。如果使用0是不是也会出现数据主键不一致，这个得查下，确认下？

gap锁，如果记录是1、5、10，那么在10上加gap锁影响的是（5，10）的区间，如果一条记录插入时，如果插入6，会找到10查看10上是否有gap锁。gap锁不区分读写，可以多个事务重复加，只是为了防止幻读设计的。10以后的gap锁怎么加，加到所在页的supremum记录上，默认存在的最大记录行
next-key只是record和gap锁的合体

插入意向锁，当插入数据时，查看后一条记录是否有gap锁，如果有就生成一个插入意向锁。实际上并没有这么干。而是采用的隐式锁方案，插入的时候并不生成锁结构，只是单纯的阻塞，等数据成功插入后。如果有一个事务要修改这条数据，那么这个事务将会为插入的记录生成锁结构，相当于延时生成锁结构。大部分的插入不会出现并发改的情况，所以就省去了生成锁结构的操作。

锁的详细结构

串行隔离级别下，如果是自动提交则读不加锁。如果是非自动提交，则读加读锁所类型与可重复读一样。这种隔离级别下也会用到mvcc，并不是说mvcc只用在读已提交和可重复读上。

不同隔离级别加锁的类型、过程、以及提前释放锁的相关东西

对每行加锁的过程是先对记录加锁再判断是否符合条件，这点很重要，这就是为什么会多锁下一个区间

只有server层有释放锁的权限，引擎层不配释放锁。所以会出现二级索引的锁数量大于一级索引上的锁数量的情况，因为某些情况通过索引下推就能在引擎层判断记录是否符合条件，如果不符合就出现了二级索引上有锁，一级索引上没锁的情况



对于update更新，如果通过id筛选，但是更新到了二级索引，那对应的二级索引记录要加锁（隐式锁）



| 隔离级别   | 读锁定匹配模式（select\update） | 下一个区间加锁类型 |
| ---------- | ------------------------------- | ------------------ |
| <=读已提交 | 区间匹配                        | record             |
|            | 精确匹配                        | 不加锁             |
|            | 唯一匹配                        | record             |
| >=可重复读 | 区间匹配                        | next-key           |
|            | 精确匹配                        | gap                |
|            | 唯一匹配                        | record             |



半一致性读：在<=读已提交级别时，锁没用的话就会被释放。那么当update一条记录时，如果这条记录被其他事务锁住了，那么理论上应该阻塞等待锁定，但是这条记录其实不一定符合server的筛选条件，所以可以直接找到可读版本记录，返回给server，server判定符合条件再来等待加锁，如果server判断不符合条件则直接跳过本条记录。如果用等待锁的方式，那就是等到锁之后返回给server，server判断不符合条件，再释放锁，结果是一样的，但白白等了半天



insert遇到唯一索引，主键

| 隔离级别   | 主键     | 唯一二级索引                                                 |
| ---------- | -------- | ------------------------------------------------------------ |
| <=读已提交 | record   | next-key（事务A插入p1,u1，事务B插入p2,u1。如果加record锁在AB都还没提交的情况下，读未提交的级别事务C来查询数据即可查到两个u1，违反了唯一约束。只有加next-key才能解决问题） |
| >=可重复读 | next-key | next-key                                                     |

上述锁是加到了唯一索引记录上，实际上后一条记录也会加





QA
innodb中的表锁几乎没啥用。那为什么说不命中索引的时候会加表锁，表锁跟意向锁的判断中的表锁从哪里来？