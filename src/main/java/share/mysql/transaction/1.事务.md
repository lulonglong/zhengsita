# Mysql事务  

## 事务特性  

	注意:事务是脱离mysql的业务概念  

- 原子性(Atomicity)  
	- 指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。mysql通过undo log实现
- 隔离性(Isolation)  
	- 多个事务并发执行的时候，事务内部的操作与其他事务是隔离的。隔离性有不同的隔离等级要求，mysql通过锁和MVCC机制实现
- 持久性(Durability)  
	- 事务一旦提交，它对数据的改变就应该是永久性的。mysql通过redo log实现  
- 一致性(Consistency)  
	- 指事务执行前后，数据处于一种符合逻辑的状态。这里的逻辑根据业务场景来定义，是指业务上的正常逻辑
	- 一致性是事务的终极目标，mysql通过原子性、隔离性、持久性来保证数据一致性，AID是达成一致性的手段。实际上原子性、隔离性即可保证一致性。

	举例：A账户有200元，转账300元出去，此时A账户余额为-100元。此时数据是不合逻辑的，这就是不一致性，为什么呢？因为你定义了一个状态，余额不能小于0。不但需要数据库层面做到一致性，逻辑层面也要一致，才能最终保证事务的一致性。 数据库保证一致性，不代表整个业务也会一致性，数据库没有一致性，上层业务就没有一致性可言。 

***

## 隔离性的实现  

- 无隔离带来的几种问题  
	- 脏读：读到了其他事务未提交的数据   
	- 不可重复读：在同一事务内，不同的时刻读到的同一批数据可能是不一样的
	- 幻读：进行中的A事务读到了后开始的B事务刚刚提交的插入数据，针对insert的

- 隔离级别(SQL标准定义的)  
	- 读未提交（READ UNCOMMITTED）  
	- 读提交 （READ COMMITTED）（我们生产环境的级别）  
	- 可重复读 （REPEATABLE READ）（mysql默认级别）  
	- 串行化 （SERIALIZABLE）

>SQL标准中不同隔离级别的问题(Innodb里的可重复读解决了幻读问题)  
![alt 不同隔离级别的问题](../assets/v2-2e1a7203478165890e2d09f36cb39857_1440w.png)  

***

## Mysql锁  

	基于锁的属性分类：共享锁、排他锁  
	基于锁的粒度分类：表锁、行锁(记录锁、间隙锁、临键锁)
	基于锁的状态分类：意向共享锁、意向排它锁

### 按属性分  

- 共享锁  
> 共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加写锁。  
![alt 共享锁](../assets/v2-a251449b6e3181eb7e722946787ec298_1440w.png)  

- 排它锁  
> 排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。  
![alt 排他锁](../assets/v2-9a6d8e8fe84799b2288cbb4fa2f27f6e_1440w.png)   

### 按粒度分  

- 表锁  
> 上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问（前提是两个锁是冲突的，后续描述也一样）  
特点： 粒度大，加锁简单，容易冲突  

- 行锁
> 锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问  
特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高  

**以下三种是行锁的实现**

- 记录锁(Record Lock)  
> 记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，事务在加锁后仅锁住表的一条记录（注意：只锁一条，锁多条就用多个记录锁）  

- 间隙锁(Gap Lock)  
> 间隙锁属于行锁中的一种，间隙锁是在事务加锁后，其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间  
> 查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（可重复读)的事务级别中，防止部分幻读问题
> RR隔离级别下，只要不出现幻读就可以把Gap锁降级成Record锁

- 临键锁(Next-Key Lock)  
> 临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。（也可以认为不是一种新类型的锁，只是前两者的结合）
select * from user_info where id>=1 and id<=9 for update ;  
会锁住ID为 1,5,9的记录；同时会锁住，1至5,5至9,9至11的区间  
![alt 各种行锁](../assets/行锁.png)

### 按状态分  
	状态锁包括意向共享锁和意向排它锁，把他们区分为状态锁的一个核心逻辑，是因为这两个锁都是描述是否可以对某一个表进行加表锁的状态，状态锁要锁的对象是表（很重要），所以在判断是否兼容的时候自然也是与其他的表锁判断
	事务要获取某些行的 S 锁，必须先获得表的 IS 锁
	事务要获取某些行的 X 锁，必须先获得表的 IX 锁
	为了提高对表加锁时的性能，避免一行一行地去遍历这张表的数据有没有被锁住。例如当A尝试加X表锁时，只能每条记录锁，当碰到一条被B加了X行锁锁住的行才知道被堵住了，为了防止这种情况。在B加X行锁时就要先对表加IX表锁，当A来对表加X琐时发现冲突，就直接等待。

 ![alt 锁冲突表](../assets/v2-37761612ead11ddc3762a4c20ddab3f3_1440w.png)

***

## 不同隔离级别的实现  
	读未提交：加写锁不加读锁
	读已提交和可重复读都是基于MVCC，读已提交写的时候加记录锁，并且无用的锁会提前释放，可重复读写的时候加临键锁，并且不提前释放无用的锁
	串行化：也基于MVCC，也是加行锁，锁类型与可重复读一致。区别在于，当设置成非自动提交时，也就是一个事务中可能包含多条语句，那么为读操作也加相应的读锁，只要这样就可以完全避免幻读了。  

 ![alt](../assets/lock-tx.png)
### 读已提交&可重复读  	
	并发控制：LBCC和MVCC
	LBCC是Lock-Based Concurrent Control的简称，意思是基于锁的并发控制  
	MVCC是Multi-Version Concurremt Control的简称，意思是基于多版本的并发控制协议，通过版本号，避免同一数据在不同事务间的竞争  

#### ReadView结构  
	ReadView是事务开启时，当前所有活跃事务（还未提交的事务）的一个集合，ReadView数据结构决定了不同事务隔离级别下数据的可见性。注意，ReadView不止有如下四个属性，还有一个事务提交编号的属性来协助清理undolog用的，这里不做讨论，详细参见undolog详解。
![alt readview数据结构](../assets/v2-ba01322104c8b77f2ccd56459f351054_720w.png)  

#### 有了readview，在访问某条记录时，按照以下步骤判断记录的某个版本是否可见(以可重复读举例，可重复读是开启事务时生成ReadView，读已提交是在每次执行sql的时候生成ReadView)

※注意，为什么同时保存row_trx_id和max_trix_id？因为事务内出现增删改查时才会分配事务id，并不是开启事务立刻分配事务id，如果第一条语句就是select，那row_trx_id就是0，所以得保存max_trix_id。这样也就理解了row_trx_id和max_trix_id并不一定谁大谁小。

1. 如果被访问版本的trx_id，与readview中的row_trx_id值相同，表明当前事务在访问自己修改过的记录，该版本可以被当前事务访问；  
2. 如果被访问版本的trx_id，小于readview中的min_trx_id值，表明生成该版本的事务在当前事务生成readview前已经提交，该版本可以被当前事务访问；  
3. 如果被访问版本的trx_id，大于或等于readview中的max_trx_id值，表明生成该版本的事务在当前事务生成readview后才开启，该版本不可以被当前事务访问； 
4. 如果被访问版本的trx_id，值在readview的[min_trx_id和max_trx_id)之间，就需要判断trx_id属性值是不是在m_ids列表中？
	- 如果在：说明创建readview时生成该版本的事务还是活跃的，该版本不可以被访问  
	- 如果不在：说明创建readview时生成该版本的事务已经被提交，该版本可以被访问；生成readview时机RC隔离级别：每次读取数据前，都生成一个readview；RR隔离级别：在第一次读取数据前，生成一个readview；  

![alt mvcc readview](../assets/09ce7f729f864af4b90edcdc54356e76_1424X808.png)

### ※可重复读对幻读的解决  
![alt](../assets/幻读1.png) 
```
MVCC的版本链只影响读操作，而不影响写操作。所以在下图事务B插入记录前后，不管事务B是否提交，事务A直接读的话读不到。但事务B提交后，A是可以更改事务B新插入的数据的。更改完毕后，这条记录的事务id就变成了A，于是就对A查询又可见了。MVCC只解决了大部分的幻读问题。
```
![alt](../assets/幻读2.png)

### ※为什么mysql的默认隔离级别是可重复读？  
	当年binlog只有statement一种模式，只同步sql语句。假设出现：查询主库会有一行记录，查询从库没有记录。
	原因是，在master上执行的是先删后插，在从库上执行的是先插后删
	在可重复读的级别下，当Seassion 1执行delete语句时，会锁住间隙。那么，Session 2执行插入语句就会阻塞住
 ![alt](../assets/20190401164924919.png)


***

## 参考文档
[程序员，知道Mysql中ACID的原理吗](https://zhuanlan.zhihu.com/p/65281198)  
[MySQL事务隔离级别和实现原理](https://zhuanlan.zhihu.com/p/117476959)  
[Mysql里的锁](https://zhuanlan.zhihu.com/p/213814000)  
[MySQL 加锁处理分析](https://www.cnblogs.com/tutar/p/5878651.html)
[MySQL 不同隔离级别，都使用了什么锁？](https://cloud.tencent.com/developer/article/2134875)
[保姆级教程！2 万字 + 30 张图搞懂 MySQL 是怎么加行级锁的？](https://mp.weixin.qq.com/s/KegqAAvI4KxDffforTQqKA)
[【169期】面试官：同学，分析一下MySQL/InnoDB的加锁过程吧](https://mp.weixin.qq.com/s/GdKNGaZ-F2vED-1j8CbQSw)

