# 并发控制的由来

我们希望多个事务尽可能的并行执行，充分的使用多CPU或多服务实例，以提高整体效率。但是并行执行的事务之间相互影响会导致数据状态的不一致，由此就产生了对并发问题，需要对并发进行有效的控制和协调。

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpeg)



# 计算机内的并发

计算机内的并发问题，主要是多线程间共享数据造成。同一时刻同一变量对不同线程呈现不同的状态值，即可见性问题。

## 可见性问题的根源

可见性的问题根源在于，计算机采用多CPU，而各CPU采用了自己专有的缓存，而CPU所采用的CPU缓存一致性协议（MESI）

由于性能问题，采用的是一种非强一致性协议，会导致多线程在同一时间访问同一数据时，访问的值不一致。

主要

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg)

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/%E5%86%99%E7%BC%93%E5%86%B2%26%E5%A4%B1%E6%95%88%E9%98%9F%E5%88%97.png)



## 解决可见性的方案：内存屏障

​	由于CPU的缓存一致性协议，采用的非强一致性协议，所以针对有强一致性需求的程序，提供了内存屏障指令，通过内存屏障指令来对内存同步提供强行干预的能力。**volatile**、**synchronized、Lock等相关能力就是采用内存屏障来实现的。

 我们从Store buffer（写缓冲）和Invalidate Queue（作废队列）开始，来认识一下内存屏障的基本机制。

### Store Buffer 写缓冲

​	CPU A指令计算后，对写操作，并不会直接把数据写入缓存，而是先写入 Store Buffer中，然后通知给所有其他CPU B、C、D这个写操作，之后继续干自己的事情。等到收到所有CPU的写信号的回应后，才把store buffer 里的东西写到 cache line 中。

### Invalidate Queue 作废队列

CPU B收到 CUP的写操作通知后，并不会立即标记自己的缓存对应line为废弃，而是加入Invalidate Queue，加入后就给CPU A返回响应。CPU B会异步读取Invalidate Queue执行标记“废弃”工作。

### 内存屏障

内存屏障有两个作用

- 阻止屏障两侧的指令重排序；
- 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。

#### 读屏障 smp_rmb()

​	在invalid queue的数据被刷完之后再执行屏障后的读操作。这个屏障实质保障了屏障后的读，读取到的都是最新数据

#### 写屏障 smp_wmb()

​	 在store buffer的数据被刷完之后再执行屏障后的写操作。

#### 读写屏障 smp_mb()

​	同时具有读屏障和写屏障功能。

### Java中内存屏障的使用

#### Volatile

- **在每个volatile写操作的前面插入一个StoreStore屏障**。

- **在每个volatile写操作的后面插入一个StoreLoad屏障**。

- **在每个volatile读操作的前面插入一个LoadLoad屏障**。

- **在每个volatile读操作的后面插入一个LoadStore屏障**。

  

  ```java
  public class VolatileDemo {
  
    public volatile boolean v;
  
    public boolean tempShare=false;
  
    public boolean tempShare1;
  
  
  
    public void write(){
  
        //插入 StoreStore (刷Store Buffer)
        v=tempShare;
        //插入 StoreLoad（全能屏障，刷Store Buffer，刷Invalidate Queue）
    }
  
    public void read(){
        //插入 LoadLoad（刷Invalidate Queue ）
        tempShare1= v;
        //插入 LoadStore（实质同loadload，只是抽象概念，刷Invalidate Queue）
  
    }
  }
  ```



#### Synchronized

synchronized底层通过获取屏障和释放屏障的配对使用保证有序性，加载屏障和存储屏障的配对使用保正可见性。最后又通过锁的排他性保障了原子性与线程安全。

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/Synchronized%E5%8E%9F%E7%90%86.png)



#### Final

- 写final域：在写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。

- 读final域：在读final域前插入了LoadLoad屏障。

  

#### Lock

Java中除synchronized锁机制外，其他各种锁都是基于volatile和cas来实现，而CAS机制里，又是用内存屏障来保证C的有效性



## 并发控制核心工具-锁

[java](https://so.csdn.net/so/search?q=java&spm=1001.2101.3001.7020)提供了两种方式来加锁，一种是关键字：synchronized，一种是concurrent包下的lock锁。

### synchronized 

使用事例

```java
//隐试synchronized (this)包装整个方法体
public synchronized void testSynchronized1(){
    int a=1;
}

public void testSynchronized2(){
  //局部加锁，并可指定锁对象
  synchronized (this.lock){
      int a=1;
  }
  
  int b=2;
}
```

**Java对象头和monitor是实现synchronized的基础**！ **Java对象头**:Hotspot虚拟机的对象头主要包括两部分数据：**Mark Word（标记字段）、Klass Pointer（类型指针）**。

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png)

#### **Klass Point**

 		klass point 是对象指向它的类元数据的指针，虚拟机通过这个指针来指向“类的实例”。类实例存储着类的元数据，比如各字段的偏移量;

#### **Mark Word**

Mark word 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等,**它是实现轻量级锁和偏向锁的关键**. 

 ![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/markword.jpeg)
##### identity_hashcode

对象的hashcode，运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。

当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。

##### thread

偏向锁的线程ID， 当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。

##### epoch

偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。

##### ptr_to_lock_record

轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。



![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84MarkWord.jpeg)



##### ptr_to_heavyweight_monitor

重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。



#### Monitor（重量级锁实现）

​		synchronized 关键字在使用的时候，往往需要指定一个对象与之关联，例如：synchronized(this)，或者 synchronized(ANOTHER_LOCK)，synchronized 如果修饰的是实例方法，那么其关联的对象实际上是 this，如果修饰的是类方法，那么其关联的对象是 this.class。总之，synchronzied 需要关联一个对象，而这个对象就是 monitor object。 monitor 的机制中，monitor object 充当着维护 mutex以及定义 wait/signal API 来管理线程的阻塞和唤醒的角色,即管程本身。 

​		前面提到管程由信号量、等待队列、wait、notify等功能组成，在Java中，信号量由MarkWord中的锁标识实现；同时，java.lang.Object 类定义了 wait()，notify()，notifyAll() 方法，这些方法的具体实现，依赖于一个叫 ObjectMonitor 模式的实现，这是 JVM 内部基于 C++ 实现的一套机制，基本原理如下所示：

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/Monitor.webp)

​		当一个线程需要获取 Object 的锁时，会被放入 EntrySet 中进行等待，如果该线程获取到了锁，成为当前锁的 owner。如果根据程序逻辑，一个已经获得了锁的线程缺少某些外部条件，而无法继续进行下去（例如生产者发现队列已满或者消费者发现队列为空），那么该线程可以通过调用 wait 方法将锁释放，进入 wait set 中阻塞进行等待，其它线程在这个时候有机会获得锁，去干其它的事情，从而使得之前不成立的外部条件成立，这样先前被阻塞的线程就可以重新进入 EntrySet 去竞争锁。这个外部条件在 monitor 机制中称为条件变量。

##### ObjectMonitor结构

在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现的，其大概结构如下：

```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0;   // 重入次数
    _waiters      = 0,   // 等待线程数
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;  // 当前持有锁的线程
    _WaitSet      = NULL;  // 调用了 wait 方法的线程被阻塞 放置在这里
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 等待锁 处于block的线程 有资格成为候选资源的线程
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }

```

 **此处基于C++提供的ObjectMonitor结构实现的Object的wait、notify等方法和Mark Word的标记完整地支持了管程（即Java的重量级锁）**

#### 锁优化

​		JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；

在Java SE 1.6里Synchronied同步锁，一共有四种状态：`无锁`、`偏向锁`、`轻量级锁`、`重量级锁`，它会随着竞争情况逐渐升级，HotSpot JVM 支持锁降级，但是锁升降级效率较低，频繁升降级的话对性能就会造成很大影响。重量级锁降级发生于 STW 阶段，降级对象为仅仅能被 VMThread 访问而没有其他 JavaThread 访问的对象。 

![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/markword.jpeg)

##### 无锁

​	无锁状态下，如需要获得锁，只需要使用CAS操作来升级为偏向锁，且javaThread指针指向当前线程。

##### 偏向锁

​		对于总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争的情况，使用偏向锁减少竞争。

当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和推出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。

仅在一个线程进入临界区时（包括多个轮流进入），允许偏向，一旦出现冲突立即膨胀为轻量级锁。 

##### 轻量级锁

引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。

轻量级锁允许一定时间的自旋等待，（认为即使发生冲突，也能在短时间内获得锁），一旦自旋超时，就膨胀为重量级锁。

##### 重量级锁

重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。



![](https://yit-integration.oss-cn-hangzhou.aliyuncs.com/crm/tech/concurrent/%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png)

锁的升级流转图

