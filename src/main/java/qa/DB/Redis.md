
## Redis基础

### 什么是 Redis

Redis 是一个开源（BSD 许可）、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。

它内置了复制（Replication）、LUA 脚本（Lua scripting）、LRU 驱动事件（LRU eviction）、事务（Transactions）和不同级别的磁盘持久化（persistence）功能，并通过 Redis 哨兵（哨兵）和集群（Cluster）保证缓存的高可用性（High availability）

### 使用 Redis 有哪些好处
* 读取速度快，因为数据存在内存中，所以数据获取快；
* 支持多种数据结构，包括字符串、列表、集合、有序集合、哈希等；
* 支持事务，且操作遵守原子性，即对数据的操作要么都执行，要么都不支持；
* 还拥有其他丰富的功能，队列、主从复制、集群、数据持久化等功能

### Redis 相比 Memcached 有哪些优势
* 数据结构：Memcache 只支持 key value 存储方式，Redis 支持更多的数据类型，比如 Key value、hash、list、set、zset；
* 多线程：Memcache 支持多线程，Redis 支持单线程；CPU 利用方面 Memcache 优于 Redis；
* 持久化：Memcache 不支持持久化，Redis 支持持久化；
* 内存利用率：Memcache 高，Redis 低（采用压缩的情况下比 Memcache 高）；
* 过期策略：Memcache 过期后，不删除缓存，会导致下次取数据数据的问题，Redis 有专门线程，清除缓存数据；
* 适用场景：Redis 适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。Memcached 适用于在动态系统中减少数据库负载，提升性能，做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）

### Redis 是单线程的吗？快的原因

Redis 确实是单线程模型，指的是执行 Redis 命令的核心模块是单线程的，而不是整个 Redis 实例就一个线程。

多线程优化：
* 执行持久化的时候，新开进程来做异步持久化的
* Redis4.0之后，在删除大key时，释放内存往往都比较耗时，所以Redis提供异步释放内存的方式，让这些耗时的操作放到另一个线程中异步去处理，从而不影响主线程的执行，提高性能。
* Redis6.0之后，网络IO也引入了多线程，但执行命令还是单线程的

#### 快的原因
1.redis是基于内存的，内存的读写速度非常快（纯内存）; 数据存在内存中，数据结构用HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。
2.单线程的优势。redis网络IO和执行命令是单线程的，省去了很多上下文切换线程的时间（避免线程切换和竞态消耗）和锁。
3.redis使用IO多路复用技术（IO multiplexing, 解决对多个I/O监听时,一个I/O阻塞影响其他I/O的问题），可以处理并发的连接（非阻塞IO）。

所谓I/O多路复用
所谓I/O多路复用指的是这样一个过程：我们拿到了一堆文件描述符(不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)， 通过调用某个函数告诉内核：“这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回”。
好处

* 可以让单个线程高效处理多个连接请求（尽量减少网络IO的时间消耗）。
* Redis在内存中操作数据的速度非常快（内存里的操作不会成为这里的性能瓶颈）。主要以上两点造就了Redis具有很高的吞吐量。

https://hogwartsrico.github.io/2020/06/24/Redis-and-Multiplexing/

### Redis 的同步机制
Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区，等 RDB 文件全部同步到从节点，从节点接受完成后将 RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。

### Pipeline

#### 是什么
使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。

#### 好处
减少了每条命令分别传输的IO开销。同时减少了系统调用的次数，因此提升了整体的吞吐能力

#### 适用场景
* 存在批量数据需要写入 Redis，并且这些数据允许一定比例的写入失败，那么可以使用 Pipeline，后期再对失败的数据进行补偿即可
* 一条命令执行失败了，后面的命令也要继续执行，待所有的执行完，一次返回

### Redis 事务

怎么理解
在 MySQL 中，事务是指一组操作中，要么全部执行，要么全部不执行。而在 Redis 也存在事务的概念。Redis 的事务可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。

#### Redis 事务为什么不支持回滚

* Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行
* Redis 的事务不支持回滚，但是执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。

### Redis 通讯协议

  resp协议

 https://juejin.cn/post/6937688561344839711

### Redis 单点吞吐量

单点 TPS 达到 8 万/秒，QPS 达到 10 万/秒。

* TPS：每秒钟最大能处理的请求数。每秒钟处理完的事务次数，一个应用系统 1s 能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求
* QPS：应用系统每秒钟最大能接受的用户访问量。每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在 Server 中有个 counter，每处理一个请求加 1，1s 后 counter=QPS

### Redis 常用的安全设置
* 端口设置
* 身份验证
* 禁用特定的命令集

### Redis 适用场景
* 可以应用于高并发读写的热数据中
* 海量数据的读写
* 数据处理业务复杂和对安全性要求较高的系统
* 扩展性要求高的数据中

## 数据结构指令

### Redis 各个数据类型最大存储量
* Strings 类型：一个 String 类型的 value 最大可以存储 512M；
* List 类型：list 的元素个数最多为 2^32-1 个，也就是 4294967295 个；
* Set 类型：元素个数最多为 2^32-1 个，也就是 4294967295 个；
* Hash 类型：键值对个数最多为 2^32-1 个，也就是 4294967295 个；
* Sorted set 类型：跟 Sets 类型相似。元素个数最多为 2^32-1 个，也就是 4294967295 个。

### Sorted Set（zset）以及底层实现机制

### String 类型使用 SDS 方式实现的好处

### 怎么发现 bigkey
可以使用 redis-cli –bigkeys 命令统计 bigkey 的分布。也可以在生产环节下执行 debug object key 命令查看 serializedlength 属性，获得 key 对应的 value 序列化之后的字节数。

#### bigkey 的主要影响有：
* 网络阻塞；获取 bigkey 时，传输的数据量比较大，会增加带宽的压力。
* 超时阻塞；因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。
* 导致内存空间不平衡；一个 bigkey 存储数据量比较大，同一个 key 在同一个节点或服务器中存储，会造成一定影响

### 过期时间和永久有效分别怎么设置

可以使用 EXPIRE 和 PERSIST 命令。对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间

PERSIST 命令可以移除给定 key 的生存时间，将这个 key 从带生存时间转换成持久的

## 高并发处理

### Redis 常见性能问题和解决方案有哪些
* Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；
* 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；
* 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；
* 热备尽量在从库上同步数据

### 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来

可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。

1. 使用 keys 命令

直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。而且 Redis 是单线程，keys 指令会导致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。这在生产环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条件的 key 值，会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。

2. 使用 scan 命令

scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行的过程不会阻塞线程，并且查找的数据可能存在重复，需要客户端操作去重。因为 scan 是通过游标方式查询的，所以不会导致 Redis 出现假死的问题。Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。scan 在检索的过程中，被删除的元素是不会被查询出来的，但是如果在迭代过程中有元素被修改，scan 不能保证查询出对应元素。相对来说，scan 指令查找花费的时间会比 keys 指令长

### MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据

1.Redis的内存淘汰策略。 allkeys-lru淘汰策略
2.Redis的最大内存设置。

思路：首先计算出20w数据所需的内存空间，设置最大内存，然后选择合适的内存淘汰策略。

内存淘汰策略

https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/23%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%AE%97%E6%B3%95.md

使用最多的淘汰策略
volatile-lru 从已设置过期的时候的找出最近最少使用的淘汰

### 什么是缓存穿透
缓存穿透是指查询数据库和缓存都无数据，因为数据库查询无数据，出于容错考虑，不会将结果保存到缓存中，因此每次请求都会去查询数据库，这种情况就叫做缓存穿透。
* 使用过滤器
  * 我们可以使用过滤器来减少对数据库的请求，例如使用我们前面章节所学的布隆过滤器，我们这里简单复习一下布隆过滤器，它的原理是将数据库的数据哈希到 bitmap 中，每次查询之前，先使用布隆过滤器过滤掉一定不存在的无效请求，从而避免了无效请求给数据库带来的查询压力。
* 缓存空结果
  * 另一种方式是我们可以把每次从数据库查询的数据都保存到缓存中，为了提高前台用户的使用体验 (解决长时间内查询不到任何信息的情况)，我们可以将空结果的缓存时间设置得短一些，例如 3~5 分钟。
* 加锁排队
  * 此处理方式和缓存雪崩加锁排队的方法类似，都是在查询数据库时加锁排队，缓冲操作请求以此来减少服务器的运行压力。
* 设置永不过期
  * 对于某些热点缓存，我们可以设置永不过期，这样就能保证缓存的稳定性，但需要注意在数据更改之后，要及时更新此热点缓存，不然就会造成查询结果的误差。

### 什么是缓存雪崩
缓存雪崩是指在短时间内，有大量缓存同时过期，导致大量的请求直接查询数据库，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机的情况叫做缓存雪崩。

常用解决方案
* 加锁排队可以起到缓冲的作用，防止大量的请求同时操作数据库，但它的缺点是增加了系统的响应时间，降低了系统的吞吐量，牺牲了一部分用户体验。
* 随机化过期时间
* 设置二级缓存

### 大量的key设置同一时间过期会有什么问题

如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致数据库崩溃。

也有可能同时失效，那么 Redis 会出现短暂的卡顿问题。所以为了预防这种问题的发生，最好给数据的过期时间加一个随机值，让过期时间更加分散。

### Redis 哨兵和集群的区别
Redis 的哨兵作用是管理多个 Redis 服务器，提供了监控、提醒以及自动的故障转移的功能。哨兵可以保证当主服务器挂了后，可以从从服务器选择一台当主服务器，把别的从服务器转移到读新的主机。Redis 哨兵的主要功能有：

* 集群监控：对 Redis 集群的主从进程进行监控，判断是否正常工作。
* 消息通知：如果存在 Redis 实例有故障，那么哨兵可以发送报警消息通知管理员。
* 故障转移：如果主机（master）节点挂了，那么可以自动转移到从（slave）节点上。
* 配置中心：当存在故障时，对故障进行转移后，配置中心会通知客户端新的主机（master）地址。

Redis 的集群的功能是为了解决单机 Redis 容量有限的问题，将数据按一定的规则分配到多台机器，对内存的每秒访问不受限于单台服务器，可受益于分布式集群高扩展性。

### 可能导致 Redis 阻塞的原因

* 如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃；
* 数据持久化占用资源过多；

### Redis 分区实现方案
客户端分区就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。

代理分区意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。Redis 和 Memcached 的一种代理实现就是 Twemproxy。

### Redis 集群之间的复制方式

主从同步过程
Slave 从节点服务启动并连接到 Master 之后，它将主动发送一个 SYNC 命令；
Master 服务主节点收到同步命令后将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master 将传送整个数据库文件到 Slave，以完成一次完全同步；
Slave 从节点服务在接收到数据库文件数据之后将其存盘并加载到内存中；
此后，Master 主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给 Slaves，Slave 将在本次执行这些数据修改命令，从而达到最终的数据同步

### 缓存双写一致性

当一个数据需要更新时，因为不可能做到同时更新数据库和缓存，那么此时读取数据的时候就一定会发生数据不一致问题

读
读的时候先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

写
更新的时候，先更新数据库，然后再删除缓存

### 分布式锁的实现方式
Redis 的 setnx 命令为原子性操作命令。只有在 key 不存在的情况下，才能 set 成功

## 持久化

### bgsave 的原理

### AOF 和 RDB的区别

### 如何选择合适的持久化方式

## 集群

### 描述一下 Redis 集群的原理

### Redis 集群的主从复制模型是怎样的

Redis 集群支持的主从复制，数据同步主要有两种方法：一种是全量同步，一种是增量同步。

1. 全量同步

刚开始搭建主从模式时，从机需要从主机上获取所有数据，这时就需要 Slave 将 Master 上所有的数据进行同步复制。复制的步骤为：

从服务器发送 SYNC 命令，链接主服务器；
主服务器收到 SYNC 命令后，进行存盘的操作，并继续收集后续的写命令，存储缓冲区；
存盘结束后，将对应的数据文件发送到 Slave 中，完成一次全量同步；
主服务数据发送完毕后，将进行增量的缓冲区数据同步；
Slave 加载数据文件和缓冲区数据，开始接受命令请求，提供操作。

2. 增量同步

从节点完成了全量同步后，就可以正式的开启增量备份。当 Master 节点有写操作时，都会自动同步到 Slave 节点上。Master 节点每执行一个命令，都会同步向 Slave 服务器发送相同的写命令，当从服务器接收到命令，会同步执行。

### Redis 集群方案应该怎么做，有哪些方案

Redis 可以使用的集群方法有：

* Redis cluster 3.0：这是 Redis 自带的集群功能，它采用的分布式算法是哈希槽，而不是一致性 hash。支持主从结构，可以扩展多个从服务器，当主节点挂了可以很快的切换到一个从节点做主节点，然后从节点都读取到新的主节点。
* Twemproxy，它是 Twitter 开源的一个轻量级后端代理，可以管理 Redis 或 Memcache 集群。它相对于 Redis 集群来说，易于管理。它的使用方法和 Redis 集群没有任何区别，只需要设置好多个 Redis 实例后，在本需要连接 redis 的地方改为连接 Twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 Redis 节点，将结果再返回 Twemproxy。对于客户端来说，Twemproxy 相当于是缓存数据库的入口，它不需要知道后端如何部署的。Twemproxy 会检测与每个节点的连接是否正常，如果存在异常节点，则会被剔除，等一段时间后，Twemproxy 还会再次尝试连接被剔除的节点。
* Codis，它是一个 Redis 分布式的解决方式，对于应用使用 Codis Proxy 的连接和使用 Redis 服务的没有明显差别，应用能够像使用单机 Redis 一样，让 Codis 底层处理请求转发，不停机的数据迁移等工作。

区别
* codis 豌豆荚的员工开发的，是采用中心化集群的方式，由代理曾proxy来进行转发，它内部维护了请求转发的具体规则，Codis把整个集群划分为1024个槽位，在处理读写请求时，采用crc32 Hash算法计算key的Hash值，然后再根据Hash值对1024个槽位取模，最终找到具体的Redis节点。
* Codis最大的特点就是可以在线扩容，在扩容期间不影响客户端的访问，也就是不需要停机。这对业务使用方是极大的便利，当集群性能不够时，就可以动态增加节点来提升集群的性能。
* Codis内置了redis，使用Codies必须使用内置的3.2.8版本的Redis，目前没人维护了。
* Twemproxy，Twitter开源的集群化方案，它的功能比较单一，只实现了请求路由转发，没有像Codis那么全面有在线扩容的功能
* Redis Cluster, 没有了Proxy层进行转发，客户端可以直接操作对应的Redis节点，这样就少了Proxy层转发的性能损耗。
* Redis Cluster在节点数据迁移、扩容缩容时，对于客户端的请求处理也做了相应的处理。当客户端访问的数据正好在迁移过程中时，服务端与客户端制定了一些协议，来告知客户端去正确的节点上访问，帮助客户端订正自己的路由规则。
* Redis Cluster提供了在线数据迁移的功能，但它的迁移性能并不高, 自动扩容的性能没有codis好。

### 一致性hash

客户端分片集群模式

客户端分片需要业务开发人员事先评估业务的请求量和数据量，然后让DBA部署足够的节点交给开发人员使用即可。

这个方案的优点是部署非常方便，业务需要多少个节点DBA直接部署交付即可，剩下的事情就需要业务开发人员根据节点数量来编写key的请求路由逻辑，制定一个规则，一般采用固定的Hash算法，把不同的key写入到不同的节点上，然后再根据这个规则进行数据读取。

它的缺点是业务开发人员使用Redis的成本较高，需要编写路由规则的代码来使用多个节点，而且如果事先对业务的数据量评估不准确，后期的扩容和迁移成本非常高，因为节点数量发生变更后，Hash算法对应的节点也就不再是之前的节点了。

所以后来又衍生出了一致性哈希算法，就是为了解决当节点数量变更时，尽量减少数据的迁移和性能问题。

一致性哈希详解
https://www.zsythink.net/archives/1182

### Redis集群节点伸缩时是怎么做到同时对外服务的
```
Redis 集群支持在线迁移槽( slot ) 和数据来完成水平伸缩，当 slot 对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能迁移，保证键命令可正常执行。例如当 slot 数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点。
所以，综合上述情况，客户端命令执行流程如下所示：

	>客户端根据本地 slot 缓存发送命令到源节点，如果存在键对应则直接执行并返回结果给客户端。
	>如果节点返回 MOVED 错误，更新本地的 slot 到 Redis 节点的映射关系，然后重新发起请求。
	>如果数据正在迁移中，节点会回复 ASK 重定向异常。格式如下: ( error ) ASK { slot } { targetIP } : { targetPort }
	>客户端从 ASK 重定向异常提取出目标节点信息，发送 asking 命令到目标节点打开客户端连接标识，再执行键命令。
	
ASK 和 MOVED 虽然都是对客户端的重定向控制，但是有着本质区别。ASK 重定向说明集群正在进行 slot 数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新 slot 到 Redis 节点的映射缓存。但是 MOVED 重定向说明键对应的槽已经明确指定到新的节点，因此需要更新 slot 到 Redis 节点的映射缓存
```
 ![alt](https://ask.qcloudimg.com/http-save/1692602/oqxysie0rt.jpeg?imageView2/2/w/1620)

## 性能优化

### Redis 过期键的删除策略
过期键的删除策略是将惰性删除策略和定期删除策略组合使用。

1. 定时删除策略

该策略的作用是给 key 设置过期时间的同时，给 key 创建一个定时器，定时器在 key 的过期时间来临时，对这些 key 进行删除。 这样做的好处是保证内存空间得以释放。但是缺点是给 key 创建一个定时器会有一定的性能损失。如果 key 很多，删除这些 key 占用的内存空间也会占用 CPU 很多时间。

2. 惰性删除策略

每次从数据库取 key 的时候检查 key 是否过期，如果过期则删除，并返回 null，如果 key 没有过期，则直接返回数据。

这样做的好处是占用 CPU 的时间比较少。但是缺点是如果 key 很长时间没有被获取，将不会被删除，容易造成内存泄露。

3. 定期删除策略

该策略的作用是每隔一段时间执行一次删除过期 key 的操作，该删除频率可以在 redis.conf 配置文件中设置。

这样做的好处是可以避免惰性删除时出现内存泄露的问题，通过设置删除操作的时长频率，可以减少 CPU 时间的占用。但是缺点是相对内存性能友好来说，该策略不如定时删除策略，相对 CPU 性能友好来说，该策略不如惰性删除策略。

Redis 采用的删除策略是将惰性删除策略和定期删除策略组合使用。

### Redis 慢查询

慢查询是指系统执行命令之后，当计算系统执行的指令时间超过设置的阀值，该命令就会被记录到慢查询中，该命令叫做慢指令。

Redis 慢查询的参数配置有：

1. slowlog-log-slower-than

该参数的作用为设置慢查询的阈值，当命令执行时间超过这个阈值就认为是慢查询。单位为微妙，默认为 10000。

可以根据自己线上的并发量进行调整这个值。如果存在高流量的场景，那么建议设置这个值为 1 毫秒，因为每个命令执行的时间如果超过 1 毫秒，那么 Redis 的每秒操作数最多只能到 1000。

2. slowlog-max-len

该参数的作用为设置慢查询日志列表的最大长度，当慢查询日志列表处于最大长度时，最早插入的一个命令将会被从列表中移除。

### Redis 的淘汰策略

Redis 提供了 6 种淘汰策略：
* volatile-lru：该淘汰策略是被使用最多的一种，从已设置过期时间的数据集（server.db [i].expires）中挑选最近最少使用的数据淘汰；而没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失；
* volatile-ttl：从已设置过期时间的数据集（server.db [i].expires）中挑选将要过期的数据淘汰，它和 volatile-lru 的区别在于 key 的剩余生存时间 ttl 的值越小越优先被淘汰，而 volatile-lru 是根据使用程度越小越被淘汰；
* volatile-random：从已设置过期时间的数据集（server.db [i].expires）中随机选择数据淘汰；
* allkeys-lru：从数据集（server.db [i].dict）中挑选最近最少使用的数据淘汰；它和 volatile-lru 淘汰机制的区别在于 allkeys-lru 针对的是全体 key 对象，淘汰的 key 不只是包括设置了过期时间的 key，也包括了没有设置过期时间的 key。而 volatile-lru 主要是针对设置了过期时间的 key 进行淘汰；
* allkeys-random：从数据集（server.db [i].dict）中随机选择数据淘汰；
* no-enviction：Redis 默认使用这种淘汰策略，当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错。它的优点在于可以保证数据不被丢失，但是它的缺点是会导致线上的业务不能持续进行的问题。这个淘汰策略下除了 DEL 请求和读请求服务可以继续被执行外，不能继续执行写请求。

### Redis 的内存用完了会发生什么
如果 Redis 的内存使用达到了 redis.conf 配置文件中的设置上限，执行 Redis 的写命令会返回错误信息，但是还是支持读操作。解决这个问题的办法是，可以开启 Redis 的淘汰机制，当 Redis 内存达到上限时可以根据配置的策略删除一些数据，防止内存用完。

## Redis 应用

### Redis 支持的 Java 客户端都有哪些
主要支持的 Java 客户端有：Redisson、Jedis、lettuce 等，官方推荐使用 Redisson

### 怎么提高缓存命中率

主要常用的手段有：
* 提前加载数据到缓存中
* 增加缓存的存储空间，提高缓存的数据
* 调整缓存的存储数据类型
* 提升缓存的更新频率

### setnx 
完整语法：SET key value [EX seconds|PX milliseconds] [NX|XX]

必选参数说明：

SET：命令
* key：待设置的key
* value：设置的key的value，最好为随机字符串
可选参数说明：
* EX seconds：设置过期时间，过期时间精确为秒
* PX millseconds：设置过期时间，过期时间精确为毫秒
* NX：表示key不存在时才设置，如果存在则返回 null
* XX：表示key存在时才设置，如果不存在则返回NULL

### redis分布式锁的问题

#### 释放了别人的锁
假如线程A和线程B，都使用lockKey加锁。线程A加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间。这时候，redis会自动释放lockKey锁。此时，线程B就能给lockKey加锁成功了，接下来执行它的业务操作。恰好这个时候，线程A执行完了业务功能，接下来，在finally方法中释放了锁lockKey。这不就出问题了，线程B的锁，被线程A释放了。

解决办法
在释放锁的时候，先获取到该锁的值(之前设置值就是requestId)，然后判断跟之前设置的值是否相同，如果相同才允许删除锁，返回成功。如果不同，则直接返回失败。
```
if (jedis.get(lockKey).equals(requestId)) { 
    jedis.del(lockKey); 
    return true; 
} 
return false; 
```

锁超时被释放，还有一个解决放啊，引入Redisson框架，原理就是搞一个守护线程，看是否需要去延长锁的超时时间

#### 大量失败请求
上面的加锁方法看起来好像没有问题，但如果你仔细想想，如果有1万的请求同时去竞争那把锁，可能只有一个请求是成功的，其余的9999个请求都会失败。

解决办法
使用自旋锁。比如500毫秒内，自旋不断尝试加锁(说白了，就是在死循环中，不断尝试加锁)，如果成功则直接返回。如果失败，则休眠50毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。

#### 不可重入

当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。

Redis Map 数据结构来实现分布式锁，既存锁的标识也对重入次数进行计数。Redission 加锁示例
```
// 如果 lock_key 不存在
if (redis.call('exists', KEYS[1]) == 0)
then
    // 设置 lock_key 线程标识 1 进行加锁
    redis.call('hset', KEYS[1], ARGV[2], 1);
    // 设置过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
    end;
// 如果 lock_key 存在且线程标识是当前欲加锁的线程标识
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1)
    // 自增
    then redis.call('hincrby', KEYS[1], ARGV[2], 1);
    // 重置过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
    end;
// 如果加锁失败，返回锁剩余时间
return redis.call('pttl', KEYS[1]);

```

#### 主节点挂了，还未同步到从节点
在包含主从模式的集群部署方式中，当主节点挂掉时，从节点会取而代之，但客户端无明显感知。当客户端 A 成功加锁，指令还未同步，此时主节点挂掉，从节点提升为主节点，新的主节点没有锁的数据，当客户端 B 加锁时就会成功。

### Redis的分布式锁和zk的分布式锁，有何区别
分布式锁该考虑哪些特性
* 首先最基本的，我们要保证同一时刻只能有一个应用的一个线程持有锁；
* 高性能，然后我们这个分布式锁可能会有很多的服务器来获取，所以我们一定要能够快速获取释放；
* 高可用，不能因某一个分布式锁获取的服务不可用，导致所有服务都不能正常加解锁，导致服务不可用；
* 失效机制，防止死锁
  * 假设某个应用获取到锁之后，一直没有来释放锁，可能服务本身已经挂掉了，不能一直不释放，导致其他服务一直获取不到锁；
* 可重入性，一个应用如果成功获取到锁之后，再次获取锁也可以成功；
* 非阻塞特性，阻塞特性
  * 在某个服务来获取锁时，假设该锁已经被另一个服务获取，我们要能直接返回失败，不能一直等待。
* 公平锁/非公平锁

那么我们可以采取哪种方式来实现分布式锁呢？目前常见的方式主要有以下三种：
* 基于数据库实现
* 基于ZooKeeper实现
* 基于Redis实现

#### 基于数据库实现
1、新建方法锁表
2、方法字段加唯一索引

优点：使用简单，不用额外引入redis，ZK等中间件；

缺点：性能受限于数据库，对比redis性能较低；如果要支持锁超时，可重入等特性需要自己实现，较为繁琐。

#### 基于Redis实现
可以基于setnx指令实现(可附加超时时间参数)

性能较好，但是可靠性不是特别好，具体不好的，见[redis分布式锁的问题]

#### 基于zk实现
zk的分布式锁，是基于临时节点的有序性和节点的监听机制完成的

大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个临时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

锁无法释放？
* 使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。

非阻塞锁？
* 使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。

不可重入？
* 使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。

单点问题？
* 使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。

#### 非公平锁
* 创建一个临时节点，其他请求watch就好了。

优点
* 可靠性较好。有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。

缺点
* 性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。

#### 总结

从理解的难易程度角度（从低到高）
* 数据库 > 缓存 > Zookeeper

从实现的复杂性角度（从低到高）
* Zookeeper >= 缓存 > 数据库

从性能角度（从高到低）
* 缓存 > Zookeeper >= 数据库

从可靠性角度（从高到低）

* Zookeeper > 缓存 > 数据库