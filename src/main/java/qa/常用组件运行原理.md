# 常用组件运行原理

## Spring

#### 容器启动
```
1.初始化容器环境，设置系统变量等
2.初始化BeanFactory并加载BeanDefinition
3.调用BeanFactoryPostProcessor
4.把BeanPostProcessor类型的bean优先实例化
5.实例化非懒加载的单例类
```
#### @Component 和 @Autowire
```
1.入口是在配置文件中配置context:component-scan标签开启自动扫描
2.在spring-context模块META-INF/spring.handlers文件中配置了自定义命名空间解析器，对应配置如下:
http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler。Spring会加载‘=’后边的配置类解析‘=’前边的命名空间
3.注册了ComponentScanBeanDefinitionParser解析器负责解析<context:component-scan/>标签，扫描指定包，通过asm加载并解析class文件，找到有注解类型的class，构建BeanDefinition
4.在扫描完包后注册了MergedBeanDefinitionPostProcessor的实现类
5.在Bean实例化时会被MergedBeanDefinitionPostProcessor处理，如果需要被注入则注入属性
```
#### AOP
```
1.入口是在配置文件中配置aop:aspectj-autoproxy标签开启AOP
2.在spring-aop模块META-INF/spring.handlers文件中配置了自定义命名空间解析器，对应配置如下:
http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler。Spring会加载‘=’后边的配置类解析‘=’前边的命名空间
3.通过AopNamespaceHandler解析<aop:aspectj-autoproxy />，注册自动代理创建类AnnotationAwareAspectJAutoProxyCreator，这个类是BeanPostProcessor的实现
4.在Bean实例化阶段，才延迟触发自动代理创建类解析所有@Aspect注解类，提取PointCut和Advice信息，并不是在自动代里创建类实例化时解析所有@Aspect注解类
5.然后过滤Advice看是否需要对该Bean做AOP处理，如果需要则生成代理对象

```
#### 事务
```

```

## MySQL

## MyBatis

### Spring-MyBatis

## Redis

## ES

## ZK

## Kafka

## Dubbo

## Disconf
